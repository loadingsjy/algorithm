
# 二维前缀和
目的是预处理出一个结构，以后每次查询二维数组任何范围上的累加和都是O(1)的操作
1 根据原始状况，生成二维前缀和数组sum，
    sum[i][j]: 代表左上角(0,0)到右下角(i,j)这个范围的累加和
    sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];
2 查询左上角(a,b)到右下角(c,d)这个范围的累加和
    sum[c][d] - sum[c][b-1] - sum[a-1][d] + sum[a-1][b-1];
3 实际过程中往往补第0行、第0列来减少很多条件判断。
    当然也可以不补。根据个人习惯决定。

-----------------------------------------------------------------------------------------------------

# 二维差分
在二维数组中，如果经历如下的过程
1 批量的做如下的操作，每个操作都有独立的a、b、c、d、v
void add(a, b, c, d, v) : 左上角(a,b)到右下角(c,d)范围上，每个数字+v，怎么快速处理？
2 操作做完后，如何正确得到二维数组中每个位置的值？

这就是二维差分的主要工作，add时候快速处理，最后build得到每个位置的值，修改操作必须集中在一起，不能边修改边查询。
1）add方法实现，比较巧妙！
2）build方法实现，和处理前缀和类似
3）真实数据用一圈0包裹起来，可以减少很多边界讨论

# 二维差分数组构造

void add(int a, int b, int c, int d, int v) {
    diff[a][b] += v;
    diff[c + 1][b] -= v;
    diff[a][d + 1] -= v;
    diff[c + 1][d + 1] += v;
}

void build() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
        }
    }
}
