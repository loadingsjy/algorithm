
并查集的使用是如下的场景
1）一开始每个元素都拥有自己的集合，在自己的集合里只有这个元素自己
2）find(i)：查找i所在集合的代表元素，代表元素来代表i所在的集合
3）boolean isSameSet(a, b)：判断a和b在不在一个集合里
4）void union(a, b)：a所在集合所有元素 与 b所在集合所有元素 合并成一个集合
5）各种操作单次调用的均摊时间复杂度为O(1)


并查集的两个优化，都发生在find方法里
1）扁平化（一定要做）
2）小挂大（可以不做，原论文中是秩的概念，可以理解为 粗略高度 或者 大小）

并查集的小扩展（下节课的题目重点展示）
可以定制信息：并查集目前有多少个集合，以及给每个集合打上标签信息

并查集时间复杂度的理解
作为如此简单、小巧的结构，
感性理解单次调用的均摊时间复杂度为O(1)即可，其实为α(n)，阿克曼函数。
当n=10^80次方即可探明宇宙原子量，α(n)的返回值也不超过6，那就可以认为是O(1)
并查集的发明者Bernard A. Galler和Michael J. Fischer，
从1964年证明到1989年才证明完毕，建议记住即可，理解证明难度很大！


并查集的小扩展:
可以定制信息：并查集目前有多少个集合，以及给每个集合打上标签信息
