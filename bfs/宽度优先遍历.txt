宽度优先遍历基本内容

bfs的特点是逐层扩散，从源头点到目标点扩散了几层，最短路就是多少
bfs可以使用的特征是 任意两个节点之间的相互距离相同（无向图）
bfs开始时，可以是 单个源头、也可以是 多个源头
bfs频繁使用队列，形式可以是 单点弹出 或者 整层弹出
bfs进行时，进入队列的节点需要标记状态，防止 同一个节点重复进出队列
bfs进行时，可能会包含 剪枝策略 的设计


bfs是一个理解难度很低的算法，难点在于 节点如何找到路、路的展开 和 剪枝设计


-----------------------------------------------------------------------

01bfs，适用于 图中所有边的权重只有0和1两种值，求源点到目标点的最短距离
时间复杂度为 O(节点数量+边的数量)，为什么不能用传统bfs？
1，distance[i]表示从源点到i点的最短距离，初始时所有点的distance设置为无穷大
2，源点进入双端队列，distance[源点]=0
3，双端队列 头部弹出 x，
   A，如果x是目标点，返回distance[x]表示源点到目标点的最短距离
   B，考察从x出发的每一条边，假设某边去y点，边权为w
      1）如果 distance[y] > distance[x] + w，处理该边；否则忽略该边
      2）处理时，更新distance[y] = distance[x] + w
         如果w==0，y从头部进入双端队列；如果w==1，y从尾部进入双端队列
      3）考察完x出发的所有边之后，重复步骤3
4，双端队列为空停止
正确性证明 以及 为什么不需要visited来标记节点

--------------------------------------------------------------------------

双向广度优先搜索：

双向广搜常见用途1：小优化
bfs的剪枝策略，分两侧展开分支，哪侧数量少就从哪侧展开

双向广搜常见用途2：重要！本体！用于解决特征很明显的一类问题
特征：全量样本不允许递归完全展开，但是半量样本可以完全展开
过程：把数据分成两部分，每部分 各自展开 计算结果，然后设计两部分结果的 整合逻辑
