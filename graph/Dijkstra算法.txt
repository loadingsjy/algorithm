* Dijkstra算法基本思路：主要思想是贪心
将所有节点分成两类：已确定从起点到当前点的最短路长度的节点，以及未确定从起点到当前点的最短路长度的节点（下面简称「未确定节点」和「已确定节点」）。

每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。
用节点 A「更新」节点 B 的意思是，用起点到节点 A 的最短路长度加上从节点 A 到节点 B 的边的长度，去比较起点到节点 B 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。

这里暗含的信息是：每次选择「未确定节点」时，起点到它的最短路径的长度可以被确定。
可以这样理解，因为我们已经用了每一个「已确定节点」更新过了当前节点，无需再次更新（因为一个点不能多次到达）。
而当前节点已经是所有「未确定节点」中与起点距离最短的点，不可能被其它「未确定节点」更新。所以当前节点可以被归类为「已确定节点」。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Dijkstra算法：给定一个源点，求解从源点到每个点的最短路径长度。单源最短路径算法。
适用范围：有向图、边的权值没有负数

彻底暴力的Dijkstra算法，不讲、时间复杂度太差、无意义

普通堆实现的Dijkstra算法，最普遍、最常用
算法核心过程：
节点弹出过就忽略
节点没弹出过，让其它没弹出节点距离变小的记录加入堆

反向索引堆实现的Dijkstra算法，最快速、最极致
核心在于掌握反向索引堆

-------------------------------------------------------------------------------

普通堆实现的Dijkstra算法，时间复杂度O(m * log m)，m为边数

1，distance[i]表示从源点到i点的最短距离，visited[i]表示i节点是否从小根堆弹出过
2，准备好小根堆，小根堆存放记录：(x点，源点到x的距离)，小根堆根据距离组织
3，令distance[源点]=0，(源点，0)进入小根堆
4，从小根堆弹出(u点，源点到u的距离)
   a. 如果visited[u] == true，不做任何处理，重复步骤4
   b. 如果visited[u] == false，令visited[u] = true，u就算弹出过了
      然后考察u的每一条边，假设某边去往v，边权为w
      1）如果visited[v] == false 并且 distance[u] + w < distance[v]
         令distance[v] = distance[u] + w，把(v, distance[u] + w)加入小根堆
      2）处理完u的每一条边之后，重复步骤4
5，小根堆为空过程结束，distance表记录了源点到每个节点的最短距离。

--------------------------------------------------------------------------------

反向索引堆实现的Dijkstra算法，时间复杂度O(m * log n)，n为节点数，m为边数

1，准备好反向索引堆，根据源点到当前点的距离组织小根堆，可以做到如下操作
   a. 新增记录(x, 源点到x的距离)   b. 当源点到x的距离更新时，可以进行堆的调整
   c. x点一旦弹出，以后忽略x       d. 弹出堆顶的记录(u, 源点到u的距离)
2，把(源点，0)加入反向索引堆，过程开始
3，反向索引堆弹出(u，源点到u的距离)，考察u的每一条边，假设某边去往v，边权为w
   1）如果v没有进入过反向索引堆里，新增记录(v, 源点到u的距离 + w)
   2）如果v曾经从反向索引堆弹出过，忽略
   3）如果v在反向索引堆里，看看源点到v的距离能不能变得更小，如果能，调整堆；不能，忽略
   4）处理完u的每一条边，重复步骤3
4 反向索引堆为空过程结束。反向索引堆里记录了源点到每个节点的最短距离。


-----------------------------------------------------------------------------------

分层图最短路，又叫扩点最短路

不把实际位置看做图上的点，而是把 实际位置及其状态的组合 看做是图上的点，然后搜索
bfs 或者 Dijkstra的过程不变，只是扩了点（分层）而已
* 原理简单，核心在于如何扩点、如何到达、如何算距离，每个题可能都不一样
